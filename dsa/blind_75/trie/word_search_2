
/*
The time complexity of the below code is m*n*len(word)*number_of_words
but since m , n is very less than len(word),num(words)
so making tries with complexity (m*n)(m*n) and then search on it len(words)*nums(words) makes sense

We basically make the tries from words array , and then do the dfs using tries
*/
type Trie struct {
	end   bool
	word  string
	alpha map[byte]*Trie
}

func (this *Trie) Insert(word string) {
	temp := this
	n := len(word)
	for i := 0; i < n; i++ {
		a := word[i]

		_, ok := temp.alpha[a]
		//fmt.Println("temp",temp.alpha[a])
		if !ok {
			temp.alpha[a] = &Trie{
				alpha: make(map[byte]*Trie, 0),
			}
		}
		//fmt.Println("a",a,"temp",temp.alpha[a],"i",i)
		temp = temp.alpha[a]
	}
	temp.end = true
	temp.word = word
}

func dfs(board [][]byte, this *Trie, i int, j int, visited [][]bool, result map[string]bool) {
	m := len(board)
	n := len(board[0])
	if this.end == true {
		result[this.word] = true
	}
	if i < 0 || i >= m || j < 0 || j >= n || visited[i][j] {
		return
	}
	c := board[i][j]
	_, ok := this.alpha[c]
	if !ok {
		return
	}
	visited[i][j] = true
	dfs(board, this.alpha[c], i-1, j, visited, result)
	dfs(board, this.alpha[c], i, j+1, visited, result)
	dfs(board, this.alpha[c], i+1, j, visited, result)
	dfs(board, this.alpha[c], i, j-1, visited, result)
	visited[i][j] = false
	return
}

func findWords(board [][]byte, words []string) []string {
	m := len(board)
	n := len(board[0])
	trie := &Trie{
		alpha: make(map[byte]*Trie, 0),
	}
	for _, word := range words {
		trie.Insert(word)
	}
	//fmt.Println("trie",trie)

	result := make(map[string]bool, 0)
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			visited := make([][]bool, m)
			for k := 0; k < m; k++ {
				visited[k] = make([]bool, n)
			}
			dfs(board, trie, i, j, visited, result)
		}
	}

	ret := make([]string, 0)
	for k, _ := range result {
		ret = append(ret, k)
	}
	return ret
}