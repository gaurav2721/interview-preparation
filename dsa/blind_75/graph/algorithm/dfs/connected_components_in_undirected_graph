/*
// Sample code to perform I/O:

fmt.Scanf("%s", &myname)            // Reading input from STDIN
fmt.Scan(&name) // will directly try to assign the inputs to the variable
fmt.Println("Hello", myname)        // Writing output to STDOUT

// Warning: Printing unwanted or ill-formatted data to output will cause the test cases to fail
*/

// Write your code here
package main

import (
	"fmt"
	//"strings"
)

type Node struct {
	val   int
	edges map[int]bool
}

type Graph map[int]*Node

func dfs(graph Graph, i int, visited map[int]bool) {
	//fmt.Println(i,visited)
	_, ok := graph[i]
	if ok && !visited[i] {
		//fmt.Println("visited",i,visited)
		visited[i] = true
		node := graph[i]
		for k, _ := range node.edges {
			if !visited[k] {
				dfs(graph, k, visited)
			}
		}
	}
}

func main() {
	//fmt.Println("main")
	n := 0
	e := 0
	fmt.Scan(&n)
	fmt.Scan(&e)
	graph := Graph{}
	//fmt.Println(n,e,graph)
	for i := 1; i <= n; i++ {
		node := &Node{
			val:   i,
			edges: make(map[int]bool, 0),
		}
		graph[i] = node
	}
	//fmt.Println(n,e,graph)

	for i := 0; i < e; i++ {
		source := 0
		dst := 0
		fmt.Scan(&source)
		fmt.Scan(&dst)
		graph[source].edges[dst] = true
	}

	//fmt.Println(n,e,graph)

	visited := make(map[int]bool, n)

	islands := 0
	for i := 1; i <= n; i++ {
		if !visited[i] {
			dfs(graph, i, visited)
			islands++
		}
	}

	fmt.Println(islands)
}
