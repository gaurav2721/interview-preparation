// The trick here is to detect that BFS with mapping the time in the queue is going to be important s
type orange struct {
	i int
	j int
	t int
}

func IsValid(grid [][]int, visited [][]bool, i, j int) bool {
	m := len(grid)
	n := len(grid[0])
	if i < 0 || i >= m || j < 0 || j >= n {
		return false
	}
	return (visited[i][j] == false) && (grid[i][j] == 1)
}

func orangesRotting(grid [][]int) int {
	m := len(grid)
	n := len(grid[0])

	q := make([]orange, 0)
	visited := make([][]bool, m)
	for i := 0; i < m; i++ {
		visited[i] = make([]bool, n)
	}

	timestamp := 0
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == 2 {
				q = append(q, orange{i: i, j: j, t: timestamp})
			}
		}
	}

	maxTimestamp := 0
	for len(q) > 0 {
		f := q[0]
		if len(q) > 1 {
			q = q[1:]
		} else {
			q = make([]orange, 0)
		}
		visited[f.i][f.j] = true
		maxTimestamp = max(maxTimestamp, f.t)

		if IsValid(grid, visited, f.i+1, f.j) {
			grid[f.i+1][f.j] = 2
			q = append(q, orange{i: f.i + 1, j: f.j, t: f.t + 1})
		}

		if IsValid(grid, visited, f.i-1, f.j) {
			grid[f.i-1][f.j] = 2
			q = append(q, orange{i: f.i - 1, j: f.j, t: f.t + 1})
		}

		if IsValid(grid, visited, f.i, f.j+1) {
			grid[f.i][f.j+1] = 2
			q = append(q, orange{i: f.i, j: f.j + 1, t: f.t + 1})
		}

		if IsValid(grid, visited, f.i, f.j-1) {
			grid[f.i][f.j-1] = 2
			q = append(q, orange{i: f.i, j: f.j - 1, t: f.t + 1})
		}
	}

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == 1 {
				return -1
			}
		}
	}

	return maxTimestamp

}